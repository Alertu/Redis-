## Redis常见问题

##### Redis数据结构

字符串，hash（字典），zset（有序集合），set（集合），pub/sub（主题订阅者模式），list（列表）



##### Redis分布式锁

先用setnx争抢锁，抢到之后给锁加一个过期时间（exprie）以免忘记释放，set可以和exprie结合使用



##### Redis中有1亿个KEY,其中有5000W个key是以相同格式前缀开头，怎么取出来？

使用KEYS，缺点是：Redis是单线程的，如果使用KEYS会使线上服务器宕机一段时间，直到指令结束才会恢复，优点：速度快，没有重复数据；
scan指令可以没有堵塞的取出，但是会有重复的数据，需要一次去重操作，速度会比keys慢



##### Redis异步队列

一般使用list做队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，需要适当的sleep一会在重试
如果实现1：N 使用 pub/sub（主题订阅者模式），缺点：当消费者下线生产的消息会丢失，需要使用专门的消息队列（rabbitmp）等



##### Redis延迟队列

使用sortedset（有序集合）那时间戳作为sort消息内容作为key调用zdd生产消息，消费者通过zrandebyscore指令获取N秒之前的数据进行轮询处理
如果有大量的key需要设置同一时间过期需要注意什么
如何设置的时间过于统一，可能到这个时间Redis会出现卡顿，一般需要在时间上面加上一个随机值，使过期时间分散一些



##### Redis如何做持久化

快照，AOF（Redis所有的操作指令，运行AOF指令时把这些指令在重新执行一遍）
bgsave做镜像全量持久化
AOF做增量全量持久化
bgsave比较耗费时间，不够实时，在关机后会造成大量数据丢失，需要AOF配合使用
Redis重启时，需要使用bgsave持久化文件重新构建内存，在使用AOF重放近期操作指令
如果突然断电会怎么样？
取决于AOF日志sync属性配置，如果不要求性能每条写指令时都sync一下磁盘就不会丢失数据，但是高性能要求下每次都使用sync不现实，一般定时sync比如1S一次
这样最多久丢失1S的数据



##### bgsave的原理？

fork和cow
fork是Redis创建子进程来进行bgsave操作，cow是指 copy on write 子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离



##### Redis同步机制

Redis可以进行主从同步，从从同步，第一次同步时，主节点需要做一次bgsave，并同时将修改的记录，记录到buffer（缓冲）中，完成之后rdb文件会全量同步到复制节点
复制节点接受完成之后将rdb镜像加载到内存，加载完成之后，在通知主节点将期间的的操作记录同步到复制节点进行重放就完成同步的过程



##### Redis集群

Redis Sentinal 高可用，如果master宕机会自动将slave提升为maser继续提供服务
Redis Cluster  扩展，当单个Redis内存不足时是使用Cluster进行分片存储
Redis淘汰策略
allkeys-lru：尝试回收使用最少的键，是新添加的内容有内存存放
volatile-lru：尝试回收使用最小的键，但是仅限于过期集合中的键，使新添加的数据有空间存放
allkeys-random：回收随机的键，是新添加的内容有地方存放
volatile-random：回收随机的键，但是仅限于过期集合中的键
volatile-ttl：回收过期集合的键，并且优先回收存活时间短的键使新添加的数据由空间存在



##### 一个字符串类型的最大容量是多少

523M



##### Redis集群的方案；都有哪些方案

twemproxy：类似于一个代理方式，使用方式和普通的redis没有区别，设置好下属的多个Redis实例后，使用时在需要连接Redis的地方改为连接twemproxy，
他会以代理的身份接收一个请求并使用一致性hasg算法，将请求转到具体的Redis，将结果在返回twemproxy，使用方式简单只需要改变连接端口；
问题：twemproxy自身单端口的压力，使用一致hash，节点数量改变的情况下，数据无法移动到新的节点
codis：目前使用最多的集群方案，效果和twemproxy一样，但是他支持在：节点数量改变的情况下，旧数据可以恢复到新的hash节点
redis cluster3.0自带的集群：特点是：他的分布式算法没有采用一致hash，而是采用hash曹的概念，以及自身支持节点设置从节点
业务代码层逻辑：起几个毫无关联的的redis实例，在代码中对key进行hash计算，然后去对应的redis实例，需要的代码要求很高，需要考虑到节点失效后的代替算法方案
实例的监控，数据震荡后自动恢复等等；



##### redis集群方案什么情况下回导致整个集群不可用？

如果有A,B,C三个节点，在没有复制模型的情况下，如果B节点失败了那么整个集群会认为缺少5501-11000这个范围槽而不可用。
如果mysql中有200W条数据，redis中只存在20W条数据，如何保证redis中全都是热数据
redis当数据到达一定的程度，会执行数据淘汰策略 allkey-lru（尝试回收使用最少的键）



##### redis实用的场景

会话缓存：redis提供持久性，不会担心数据丢失的问题，就和购物车一样，使用redis后，就不会存在用户退出后购物车不存在的问题。，
全页缓存（FPC）：redis提供一种简单的FPC平台，回到一致性的问题
队列
Redis提供list和set，这使redis能作为一个很好的消息队列平台来使用
有序集合sorted set ：如果我们要从有序集合获取排名靠前的的10个用户 我们需要：zrange user_sorts 0 10 withsortes
Redisson：是高级的分布式协调redis客服器
Redis  hash槽的概念
Redis集群没有使用一致性的hash，而是引入的hash的概念，Redis集群中有16384个哈希槽，每个key通过CRC16校验后对16384取模决定放置到那个槽，集群的每个节点
负责部分hash槽



##### redis最大的集群数是多少

16384个



##### Redis集群之间是如何复制的

异步复制



##### 怎么理解Redis事物

事物是单独的隔离操作，事物中的所有命令都会序列化，按顺序的执行，事物在执行的过程中不会被外来的操作指令而改变
事物是原子性的，如果成功都成功，一个失败都不会失败



##### Redis关于事物的相关命令

MULTI,EXEC,WATCH,DISCARD



##### 过期时间

exprie、persist



##### Redis如何做内存优化？

尽可能使用散列表，hashes，散列表（hashes说是散列表里面存储的数少）使用内存非常小，所以应该尽可能将数据模型抽象到一个散列表里面，如果web系统中有一个
用户对象  不要为这个用户的 昵称，年龄，性别，邮箱单独设置key，而是应该吧用户的所有信息都存到散列表中

##### Redis回收使用的算法是：LRU



##### Redis怎么大批量的插入数据

Redis-cil支持一种新的pipe-mode的新模式用于执行大量的数据插入工作



##### Reids为什么分区

分区可以让redis管理更大内存，redis将可以使用所有机器的内存，如果没有分区，只能使用一个机器的的内存，分区使redis的计算能力提高



##### redis分区的方案

客户端分区就是在客户端就已经决定数据会存到那个redis节点中或者从那个redis节点读取
代理分区 意味着将请求发送给代理
